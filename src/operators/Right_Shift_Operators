âœ… Day 90 â€“ Java Right Shift Operator (>>)
ğŸ”¹ What is Right Shift Operator?
The right shift operator (>>) shifts the bits of a number to the right by the specified number of positions.
Each right shift divides the number by 2, dropping the rightmost bits.

ğŸ“Œ Syntax:
java
Copy
Edit
int result = number >> positions;
ğŸ’¡ Important Notes:
Sign bit (leftmost bit) is preserved â†’ so it works correctly with negative numbers.
Equivalent to integer division by 2â¿ (n = shift count).

Fills leftmost bits with the sign bit (0 for positive, 1 for negative).
âš–ï¸ Right Shift vs Unsigned Right Shift
Operator	Sign Propagation	Fills with
>>	Yes	Sign Bit
>>>	No	0 (zero)

âœ… Use Cases:
Efficient integer division by powers of 2.
Working with binary data (e.g., compression, encryption).
Preserving sign while shifting.

Comparision Between >> and <<
No, sign bit preservation is not applicable in left shift (<<).
Letâ€™s break it down in simple terms:

âœ… Right Shift (>>) â€“ Sign bit is preserved
This means if the number is negative, the leftmost bit (sign bit) stays 1.

This helps to keep the number negative after the shift.

Example:

java
Copy
Edit
int x = -8;
System.out.println(x >> 1);  // Output: -4
â†’ -8 is represented in binary as: 11111111 11111111 11111111 11111000
â†’ After >> 1: 11111111 11111111 11111111 11111100 (which is -4)

âŒ Left Shift (<<) â€“ Sign bit is not preserved
It just shifts all bits to the left, and inserts 0 at the right.

If the leftmost bit becomes 1 after the shift, the number becomes negative (in signed integers).

So left shifting a positive number can turn it into negative.

Example:

java
Copy
Edit
int x = 1000000000; // positive
System.out.println(x << 1);  // May become negative
| Operator | Sign Bit Preserved? | Safe for Negative Numbers? |
| -------- | ------------------- | -------------------------- |
| `>>`     | âœ… Yes               | âœ… Yes                      |
| `<<`     | âŒ No                | âŒ No                       |
